// SPDX-License-Identifier: MIT
pragma solidity >=0.8.21;

/* Autogenerated file. Do not edit manually. */

// Import schema type
import {SchemaType} from "@latticexyz/schema-type/src/solidity/SchemaType.sol";

// Import store internals
import {IStore} from "@latticexyz/store/src/IStore.sol";
import {StoreSwitch} from "@latticexyz/store/src/StoreSwitch.sol";
import {StoreCore} from "@latticexyz/store/src/StoreCore.sol";
import {Bytes} from "@latticexyz/store/src/Bytes.sol";
import {Memory} from "@latticexyz/store/src/Memory.sol";
import {SliceLib} from "@latticexyz/store/src/Slice.sol";
import {EncodeArray} from "@latticexyz/store/src/tightcoder/EncodeArray.sol";
import {FieldLayout, FieldLayoutLib} from "@latticexyz/store/src/FieldLayout.sol";
import {Schema, SchemaLib} from "@latticexyz/store/src/Schema.sol";
import {PackedCounter, PackedCounterLib} from "@latticexyz/store/src/PackedCounter.sol";
import {ResourceId} from "@latticexyz/store/src/ResourceId.sol";
import {RESOURCE_TABLE, RESOURCE_OFFCHAIN_TABLE} from "@latticexyz/store/src/storeResourceTypes.sol";
import {PileType} from "../codegen/common.sol";


ResourceId constant _tableId = ResourceId.wrap(
    bytes32(abi.encodePacked(RESOURCE_TABLE, bytes14(""), bytes16("PlayerCardsDisca")))
);

FieldLayout constant _fieldLayout = FieldLayout.wrap(
    0x0000000100000000000000000000000000000000000000000000000000000000
);

ResourceId constant _tableDiscardId = ResourceId.wrap(
    bytes32(abi.encodePacked(RESOURCE_TABLE, bytes14(""), bytes16("PlayerCardsDisca")))
);

ResourceId constant _tableEquipId = ResourceId.wrap(
    bytes32(abi.encodePacked(RESOURCE_TABLE, bytes14(""), bytes16("PlayerCardsEquip")))
);

ResourceId constant _tableSecretId = ResourceId.wrap(
    bytes32(abi.encodePacked(RESOURCE_TABLE, bytes14(""), bytes16("PlayerCardsSecre")))
);

ResourceId constant _tableTempId = ResourceId.wrap(
    bytes32(abi.encodePacked(RESOURCE_TABLE, bytes14(""), bytes16("PlayerCardsTemp")))
);

ResourceId constant _tableDeckId = ResourceId.wrap(
    bytes32(abi.encodePacked(RESOURCE_TABLE, bytes14(""), bytes16("PlayerCardsDeck")))
);

ResourceId constant _tableHandId = ResourceId.wrap(
    bytes32(abi.encodePacked(RESOURCE_TABLE, bytes14(""), bytes16("PlayerCardsHand")))
);

ResourceId constant _tableIdBoardId = ResourceId.wrap(
    bytes32(abi.encodePacked(RESOURCE_TABLE, bytes14(""), bytes16("PlayerCardsBoard")))
);



library CardTableLib {

//    enum PileType {
//        None,
//        Board,
//        Hand,
//        Deck,
//        Discard,
//        Secret,
//        Equipped,
//        Temp
//    }

    /**
     * @notice Get the table values' field layout.
   * @return _fieldLayout The field layout for the table.
   */
    function getFieldLayout() internal pure returns (FieldLayout) {
        return _fieldLayout;
    }

    /**
     * @notice Get the table's key schema.
   * @return _keySchema The key schema for the table.
   */
    function getKeySchema() internal pure returns (Schema) {
        SchemaType[] memory _keySchema = new SchemaType[](1);
        _keySchema[0] = SchemaType.BYTES32;

        return SchemaLib.encode(_keySchema);
    }

    /**
     * @notice Get the table's value schema.
   * @return _valueSchema The value schema for the table.
   */
    function getValueSchema() internal pure returns (Schema) {
        SchemaType[] memory _valueSchema = new SchemaType[](1);
        _valueSchema[0] = SchemaType.BYTES32_ARRAY;

        return SchemaLib.encode(_valueSchema);
    }

    /**
     * @notice Get the table's key field names.
   * @return keyNames An array of strings with the names of key fields.
   */
    function getKeyNames() internal pure returns (string[] memory keyNames) {
        keyNames = new string[](1);
        keyNames[0] = "key";
    }

    /**
     * @notice Get the table's value field names.
   * @return fieldNames An array of strings with the names of value fields.
   */
    function getFieldNames() internal pure returns (string[] memory fieldNames) {
        fieldNames = new string[](1);
        fieldNames[0] = "value";
    }

    /**
     * @notice Get value.
   */
    function get(bytes32 key) internal view returns (bytes32[] memory value) {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;

        bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 0);
        return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes32());
    }

    /**
     * @notice Set value.
   */
    function set(bytes32 key, bytes32[] memory value) internal {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;

        StoreSwitch.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((value)));
    }

    /**
     * @notice Get the length of value.
   */
    function lengthValue(bytes32 key) internal view returns (uint256) {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;

        uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 0);
        unchecked {
            return _byteLength / 32;
        }
    }

    /**
     * @notice Get the length of value.
   */
    function length(bytes32 key) internal view returns (uint256) {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;

        uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 0);
        unchecked {
            return _byteLength / 32;
        }
    }

    /**
     * @notice Get the length of value.
   */
    function _length(bytes32 key) internal view returns (uint256) {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;

        uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 0);
        unchecked {
            return _byteLength / 32;
        }
    }

    /**
     * @notice Get an item of value.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
    function getItemValue(bytes32 key, uint256 _index) internal view returns (bytes32) {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;

        unchecked {
            bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 32, (_index + 1) * 32);
            return (bytes32(_blob));
        }
    }

    /**
     * @notice Get an item of value.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
    function _getItemValue(bytes32 key, uint256 _index) internal view returns (bytes32) {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;

        unchecked {
            bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 32, (_index + 1) * 32);
            return (bytes32(_blob));
        }
    }

    /**
     * @notice Get an item of value.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
    function getItem(bytes32 key, uint256 _index) internal view returns (bytes32) {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;

        unchecked {
            bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 32, (_index + 1) * 32);
            return (bytes32(_blob));
        }
    }

    /**
     * @notice Get an item of value.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
    function _getItem(bytes32 key, uint256 _index) internal view returns (bytes32) {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;

        unchecked {
            bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 32, (_index + 1) * 32);
            return (bytes32(_blob));
        }
    }

    /**
     * @notice Update an element of value at `_index`.
   */
    function updateValue(bytes32 key, uint256 _index, bytes32 _element) internal {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;

        unchecked {
            bytes memory _encoded = abi.encodePacked((_element));
            StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 32), uint40(_encoded.length), _encoded);
        }
    }

    /**
     * @notice Update an element of value at `_index`.
   */
    function _updateValue(bytes32 key, uint256 _index, bytes32 _element) internal {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;

        unchecked {
            bytes memory _encoded = abi.encodePacked((_element));
            StoreCore.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 32), uint40(_encoded.length), _encoded);
        }
    }

    /**
     * @notice Update an element of value at `_index`.
   */
    function update(bytes32 key, uint256 _index, bytes32 _element) internal {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;

        unchecked {
            bytes memory _encoded = abi.encodePacked((_element));
            StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 32), uint40(_encoded.length), _encoded);
        }
    }

    /**
     * @notice Update an element of value at `_index`.
   */
    function _update(bytes32 key, uint256 _index, bytes32 _element) internal {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;

        unchecked {
            bytes memory _encoded = abi.encodePacked((_element));
            StoreCore.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 32), uint40(_encoded.length), _encoded);
        }
    }

    /**
     * @notice Delete all data for given keys.
   */
    function deleteRecord(bytes32 key) internal {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;

        StoreSwitch.deleteRecord(_tableId, _keyTuple);
    }

    /**
     * @notice Delete all data for given keys.
   */
    function _deleteRecord(bytes32 key) internal {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;

        StoreCore.deleteRecord(_tableId, _keyTuple, _fieldLayout);
    }

    /**
     * @notice Tightly pack dynamic data lengths using this table's schema.
   * @return _encodedLengths The lengths of the dynamic fields (packed into a single bytes32 value).
   */
    function encodeLengths(bytes32[] memory value) internal pure returns (PackedCounter _encodedLengths) {
        // Lengths are effectively checked during copy by 2**40 bytes exceeding gas limits
        unchecked {
            _encodedLengths = PackedCounterLib.pack(value.length * 32);
        }
    }

    /**
     * @notice Tightly pack dynamic (variable length) data using this table's schema.
   * @return The dynamic data, encoded into a sequence of bytes.
   */
    function encodeDynamic(bytes32[] memory value) internal pure returns (bytes memory) {
        return abi.encodePacked(EncodeArray.encode((value)));
    }

    /**
     * @notice Encode all of a record's fields.
   * @return The static (fixed length) data, encoded into a sequence of bytes.
   * @return The lengths of the dynamic fields (packed into a single bytes32 value).
   * @return The dyanmic (variable length) data, encoded into a sequence of bytes.
   */
    function encode(bytes32[] memory value) internal pure returns (bytes memory, PackedCounter, bytes memory) {
        bytes memory _staticData;
        PackedCounter _encodedLengths = encodeLengths(value);
        bytes memory _dynamicData = encodeDynamic(value);

        return (_staticData, _encodedLengths, _dynamicData);
    }

    /**
     * @notice Encode keys as a bytes32 array using this table's field layout.
   */
    function encodeKeyTuple(bytes32 key) internal pure returns (bytes32[] memory) {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;

        return _keyTuple;
    }

    function getTableId(PileType pile) internal pure returns (ResourceId){
        if (pile == PileType.Board) {
            return _tableIdBoardId;
        }
        if (pile == PileType.Hand) {
            return _tableHandId;
        }
        if (pile == PileType.Deck) {
            return _tableDeckId;
        }
        if (pile == PileType.Discard) {
            return _tableDiscardId;
        }
        if (pile == PileType.Secret) {
            return _tableSecretId;
        }
        if (pile == PileType.Equipped) {
            return _tableEquipId;
        }
        if (pile == PileType.Temp) {
            return _tableTempId;
        }
        revert("no ResourceId");
    }

    /**
 * @notice Get value.
   */
    function getValue(PileType pile, bytes32 key) internal view returns (bytes32[] memory value) {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;
        ResourceId real_table_id = getTableId(pile);

        bytes memory _blob = StoreSwitch.getDynamicField(real_table_id, _keyTuple, 0);
        return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes32());
    }

    /**
 * @notice Set value.
   */
    function setValue(PileType pile, bytes32 key, bytes32[] memory value) internal {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;
        ResourceId real_table_id = getTableId(pile);

        StoreSwitch.setDynamicField(real_table_id, _keyTuple, 0, EncodeArray.encode((value)));
    }

    /**
 * @notice Pop an element from value.
   */
    function popValue(PileType pile, bytes32 key) internal {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;
        ResourceId real_table_id = getTableId(pile);

        StoreSwitch.popFromDynamicField(real_table_id, _keyTuple, 0, 32);
    }

    function removeElementFromArray(bytes32[] memory array, bytes32 target) internal pure returns (bytes32[] memory) {
        uint256 index = findElementIndex(array, target);
        if (index >= array.length) {
            return array;
        }

        bytes32[] memory newArray = new bytes32[](array.length - 1);
        for (uint256 i = 0; i < array.length; i++) {
            if (i < index) {
                newArray[i] = array[i];
            } else if (i > index) {
                newArray[i - 1] = array[i];
            }
        }
        return newArray;
    }

    function remove(bytes32 key) internal {

    }

    function findElementIndex(bytes32[] memory array, bytes32 target) private pure returns (uint256) {
        for (uint256 i = 0; i < array.length; i++) {
            if (array[i] == target) {
                return i;
            }
        }
        return array.length;
    }

    /**
 * @notice Push an element to value.
   */
    function pushValue(PileType pile, bytes32 key, bytes32 _element) internal {
        bytes32[] memory _keyTuple = new bytes32[](1);
        _keyTuple[0] = key;
        ResourceId real_table_id = getTableId(pile);

        StoreSwitch.pushToDynamicField(real_table_id, _keyTuple, 0, abi.encodePacked((_element)));
    }
}
